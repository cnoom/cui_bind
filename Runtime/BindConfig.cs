using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace CUiAutoBind
{
    /// <summary>
    /// AutoBind 配置类，用于管理代码生成参数
    /// </summary>
    [CreateAssetMenu(fileName = "AutoBindConfig", menuName = "CUiAutoBind/Config")]
    public class BindConfig : ScriptableObject
    {
        /// <summary>
        /// 命名空间名称
        /// </summary>
        public string namespaceName = "UI";

        /// <summary>
        /// 基础生成路径（相对 Assets/）
        /// </summary>
        public string basePath = "Scripts/UI/Auto/";

        /// <summary>
        /// 生成类的基类名称
        /// </summary>
        public string baseClass = "MonoBehaviour";

        /// <summary>
        /// 生成类实现的接口列表
        /// </summary>
        public string[] interfaces = new string[0];

        /// <summary>
        /// 是否使用 partial class
        /// </summary>
        public bool usePartialClass = true;

        /// <summary>
        /// 是否在字段上添加注释
        /// </summary>
        public bool addFieldComments = true;

        /// <summary>
        /// 额外的命名空间引用（自动添加到生成的代码中）
        /// </summary>
        public string[] additionalNamespaces = new string[0];

        /// <summary>
        /// 自动生成区域的标记字符串
        /// </summary>
        public const string AutoBindRegionStart = "#region AutoBind Generated";
        public const string AutoBindRegionEnd = "#endregion AutoBind Generated";
        public const string ManualRegionStart = "#region Manual Code";
        public const string ManualRegionEnd = "#endregion Manual Code";

        /// <summary>
        /// 获取完整的命名空间声明
        /// </summary>
        public string GetNamespaceDeclaration()
        {
            return string.IsNullOrEmpty(namespaceName) ? "" : $"namespace {namespaceName}";
        }

        /// <summary>
        /// 获取类的基类和接口声明
        /// </summary>
        public string GetClassInheritance()
        {
            var parts = new List<string>();

            if (!string.IsNullOrEmpty(baseClass))
            {
                parts.Add(baseClass);
            }

            if (interfaces != null && interfaces.Length > 0)
            {
                foreach (var iface in interfaces)
                {
                    if (!string.IsNullOrEmpty(iface))
                    {
                        parts.Add(iface);
                    }
                }
            }

            return parts.Count > 0 ? " : " + string.Join(", ", parts) : "";
        }

        /// <summary>
        /// 验证配置是否有效
        /// </summary>
        public bool IsValid()
        {
            return !string.IsNullOrEmpty(basePath);
        }

        /// <summary>
        /// 获取文件路径（公共方法）
        /// </summary>
        private string GetFilePath(string gameObjectName, string fileName)
        {
            return System.IO.Path.Combine("Assets", basePath.Trim('/'), gameObjectName, fileName);
        }

        /// <summary>
        /// 获取自动生成文件的完整路径
        /// </summary>
        public string GetAutoGeneratedFilePath(string gameObjectName)
        {
            return GetFilePath(gameObjectName, $"{gameObjectName}.Auto.cs");
        }

        /// <summary>
        /// 获取手动文件的完整路径
        /// </summary>
        public string GetManualFilePath(string gameObjectName)
        {
            return GetFilePath(gameObjectName, $"{gameObjectName}.cs");
        }

        /// <summary>
        /// 获取生成类的完整路径（兼容旧版）
        /// </summary>
        public string GetGeneratedFilePath(string gameObjectName)
        {
            return usePartialClass ? GetAutoGeneratedFilePath(gameObjectName) : GetManualFilePath(gameObjectName);
        }
    }
}
